#summary S3M (AdLib) Lite format

= S3MAL - S3M (AdLib) Lite =

[S3M] is a nice format for store AdLib songs (digital sampled version - which is the most common as with any module format - is not interesting for us now). However it has some complexity which is not always needed if we want only AdLib instruments, easy usage on a C64, and so on.

S3MAL is my own creation to have a simplified format. Strictly speaking, it's not even a format, the converter which produces S3MAL from S3M generates assembly files which must be compiled with the [cc65 CA65 assembler]. You can - in theory - assemble that file (into a separate "binary"), but it's useless, as information encoded as labels. This is natural however, since the purpose of S3MAL is to build a song into your program (to link with the player code which uses the provided labels): *it's not a loadable format*.

For sure, for shorter songs using [DRO] or [IMF] format is better but it wastes memory a lot: every AdLib register event is described, using a structured format with separated instrument information (like [S3M] in general, or the "simplified" format S3MAL) the size can be smaller - however you need more CPU power to decode/play though.

= Details =

The generated assembly file (which is [cc65 CA65 assembler] syntax!) contains the following important labels you must use:

 * s3mal_patterns_lo
 * s3mal_patterns_hi

Low&high bytes of the addresses of the patterns. Note: there is no "order table"! The pattern table is used as order table too: your player should simply play patterns specified here, until "song end" information is found during pattern decoding (see later).

 * s3mal_inst_lo
 * s3mal_inst_hi

Low&high bytes of the addresses of the instruments.

== Instruments ==

== Patterns ==

First, an important note: [S3M] specifies that patterns should be always 64 rows in size. In S3MAL there is no an exact size. The pattern can be smaller and longer too. It's really not important to know, only if you have some special command (jump) in the patterns. Then, converter will encode the patterns in a way that it will work. But you must not treat to have standard [S3M] patterns! It's also possible that the pattern table contain a *single* entry: a pattern with hundreds of rows, and that contains the whole song! It helps to decrease the complexity of the file, and also playing code use more CPU of course, if you need to "seek" to a new pattern. It's the converter task to optimize and "decide" how to "slice" the song into patterns: there is no relation with the original [S3M] patterns at all (only with some special commands).

Unlike [S3M]'s pattern, you always have 9 channels, no more or less. These are always mapped directly to the 9 AdLib channels, no channel mapping.

The pattern "compression" algorithm is somewhat similar to the [S3M]'s but with some modifications. The algorithm is about this:

 * seek to the needed pattern (given by pattern table)
 * now read a single byte
 * if bit 7 is set, it's a *special* byte, the following points does not apply, read later at bit 7 related lines again
 * otherwise, the lower 4 bits contain the AdLib channel, only values 0-8 are valid (S3MAL files should not have other values)
 * the high 4 bites encodes the need of reading more byte(s)
 * if bit 4 is 1, read two byes, the first is the note, the second is the instrument number. if bit 4 is zero, the default value is assumed: no new tone is generated here. Note=$FE is a special value: it's the AdLib key-off event as with [S3M].
 * if bit 5 is 1, read one byte: it adjust the volume of the channel. If bit 5 is zero, there is no change in the volume.
 * if bit 6 is 1, read two bytes: the first is the command code, the second is the command data. If bit 6 is zero, no command.
 * if bit 7 is set, it's a special byte, the the meaning of the bits etc does not apply! So "negative numbers" (can be tested with BPL/BMI in assembly) are the special ones.
 * play (or not play - if there is nothing to do) and/or process pattern command (if any), keep the timing in your mind, then continue with the "now read a single byte" step (unless the pattern is over, the song is over, or a command specifies some special jump instruction)

The special bytes (bit 7 is set):

 * $FF: end of the whole pattern
 * $FE: end of the row
 * $FD: end of the *whole song*
 * $Ex: skip "x" number for rows, they are treated as empty ones

Other values are not used.

The default ("empty") values for tone/instrument/volume/command is the same as with [S3M]. Also the commands.